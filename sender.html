<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Feed remoto (emisor)</title>
<style>
  body {
    background: #0d1117;
    color: #fff;
    font-family: 'Segoe UI', sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 10px;
    padding: 20px;
  }
  video {
    width: 80%;
    border-radius: 10px;
    margin-top: 10px;
  }
  button {
    background: #238636;
    border: none;
    color: #fff;
    padding: 10px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 15px;
    transition: background 0.2s ease;
  }
  button:hover { background: #2ea043; }
</style>
</head>
<body>
  <h2>游니 Enviar mi c치mara a la PC receptora</h2>
  <video id="localVideo" autoplay muted playsinline></video>
  <div style="display:flex; gap:8px;">
    <button id="startBtn">Iniciar y compartir c치mara</button>
    <button id="stopBtn" disabled>Detener</button>
  </div>
  <p id="log" style="color:#ddd;"></p>

<script>
const bc = new BroadcastChannel("webrtc-signal");

// Generar senderId 칰nico por pesta침a (simple)
const senderId = Math.random().toString(36).slice(2,9);
let pc = null;
let localStream = null;
const logEl = document.getElementById('log');

function log(msg) { console.log(msg); logEl.textContent = msg; }

document.getElementById("startBtn").onclick = async () => {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
    const video = document.getElementById("localVideo");
    video.srcObject = localStream;

    pc = new RTCPeerConnection();

    pc.onicecandidate = (e) => {
      if (e.candidate) {
        bc.postMessage({ type: "ice", from: senderId, ice: e.candidate && { candidate: e.candidate.candidate, sdpMid: e.candidate.sdpMid, sdpMLineIndex: e.candidate.sdpMLineIndex } });
      }
    };

    // A침adir tracks al peer connection
    for (const track of localStream.getTracks()) {
      pc.addTrack(track, localStream);
    }

    const offer = await pc.createOffer();
await pc.setLocalDescription(offer);

// Enviar objeto plano con type y sdp (portable)
bc.postMessage({ type: "offer", from: senderId, offer: { type: pc.localDescription.type, sdp: pc.localDescription.sdp } });

    log('Offer enviada. Esperando answer...');
    document.getElementById("startBtn").disabled = true;
    document.getElementById("stopBtn").disabled = false;
  } catch (err) {
    alert("Error al acceder a la c치mara: " + err.message);
  }
};

document.getElementById("stopBtn").onclick = async () => {
  if (localStream) localStream.getTracks().forEach(t => t.stop());
  if (pc) pc.close();
  pc = null;
  localStream = null;
  log('Compartici칩n detenida');
  document.getElementById("startBtn").disabled = false;
  document.getElementById("stopBtn").disabled = true;
};

bc.onmessage = async (event) => {
  const data = event.data || {};
  const { type } = data;
  if (type === "answer") {
    // answer destinado a este sender?
    if (data.to === senderId && data.answer) {
      if (!pc) {
        console.warn("No hay pc para procesar answer");
        return;
      }
      await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
      log('Answer recibida y aplicada. Conexi칩n establecida.');
    }
  } else if (type === 'ice') {
    // ICE candidate: si viene from == receiver maybe; solo a침adimos si pc existe
    if (data.to === senderId && data.ice && pc) {
      try {
        await pc.addIceCandidate(new RTCIceCandidate(data.ice));
      } catch(e){ console.warn(e); }
    } else if (data.from === 'receiver' && data.ice && pc) {
      // por si el receptor manda con from=receiver
      try { await pc.addIceCandidate(new RTCIceCandidate(data.ice)); } catch(e){ console.warn(e); }
    } else if (data.from === senderId) {
      // ignore our own ice
    }
  }
};
</script>
</body>
</html>
